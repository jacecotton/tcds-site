{"version":3,"sources":["tcds.js","Component.js","slugify.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","prototype","Component","element","_this","this","state","Proxy","stateHandler","set","_props","prop","console","warn","context","debouncedSync","stateBatch","addEventListener","event","newState","detail","prevState","window","cancelAnimationFrame","requestAnimationFrame","sync","_this2","get","store","indexOf","toString","call","dispatchEvent","CustomEvent","String","slugify","separator","undefined","trim","normalize","replace","toLowerCase"],"mappings":"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","file":"tcds.js","sourcesContent":[null,"/**\n * A superclass for scripting components with state-driven DOM manipulation.\n *\n * Note that this utility has no \"render\" functionality. Rather, it assumes pre-\n * existing markup, and simply provides a way to manipulate DOM dynamically\n * according to the current value of some state.\n *\n * @param {HTMLElement} element - The root-most HTML element to which the\n * component script applies.\n * @param {object} props - Static properties of the component instance.\n *\n * @property {object} state - An object for keeping track of the component's\n * state. Changes to this object are intercepted by a proxy, which then emits a\n * `state-change` event, triggering the component's local `sync` method, which\n * is responsible for updating the DOM, while batching and passing the changed\n * state data to the method for reference (thereby keeping the state and the\n * DOM in \"sync\").\n * @property {object} props - An object for referencing static properties passed\n * to the component at time of instantiation.\n */\n class Component {\n  constructor(element, props) {\n    // Make the element accessible as a property of the extending class.\n    this.element = element;\n\n    /**\n     * Set up a proxy to intercept changes to `this.state`. Will check that the\n     * new value is actually different, then fires a custom event to notify\n     * listeners of the change, with details about that change.\n     */\n    this.state = new Proxy({ }, this.stateHandler());\n\n    /**\n     * Set up a proxy to intercept changes to `this.props`. Will first merge the\n     * passed `props` argument to the object so they are accessible as a\n     * property of `this`. Then it will ensure these properties are immutable so\n     * they cannot be changed at runtime.\n     */\n    this.props = new Proxy({...props}, {\n      // `_props` references the new `this.props` object (rather than the\n      // original `props` argument).\n      set: (_props, prop, value) => {\n        // If the prop already exists and is different from the attempted\n        // value...\n        if(prop in _props && _props[prop] !== value) {\n          // Reject attempt.\n          console.warn(\"Attempt to mutate prop rejected. This is a problem in component subclass. Try deriving state from prop, or mutate prop value at time of instantiation.\", {\n            context: this.element,\n            prop: prop,\n            \"attempted value\": value,\n            \"persisting value\": _props[prop],\n          });\n        } else {\n          // Otherwise proceed with setting the prop as normal.\n          _props[prop] = value;\n        }\n\n        return true;\n      },\n    });\n\n    /**\n     * Listen for state changes and then call the `sync` method to update DOM.\n     *\n     * First, wait to update the DOM until all back-to-back state changes have\n     * finished (debouncing), then pass all the changed state as one object to\n     * the `sync` method (batching).\n     */\n\n    // Keep track of whether to debounce.\n    this.debouncedSync = null;\n    // Init a collection of changed state to pass to the sync method all at\n    // once.\n    this.stateBatch = {};\n\n    // When state updates...\n    this.element.addEventListener(\"state-change\", (event) => {\n      // Update the collection of changed state properties with their new and\n      // previous values.\n      this.stateBatch.newState = { ...this.stateBatch.newState, ...event.detail.newState };\n      this.stateBatch.prevState = { ...this.stateBatch.prevState, ...event.detail.prevState };\n\n      // `debouncedSync` will be defined as a `requestAnimationFrame` (see\n      // below) if the current listener has already been triggered. So if\n      // `debouncedSync` is not `null` (as initialized), state has been changed\n      // multiple times before the next available animation frame (i.e. back-to-\n      // back). So, cancel the existing request and try again on the next\n      // animation frame.\n      if(this.debouncedSync !== null) {\n        window.cancelAnimationFrame(this.debouncedSync);\n      }\n\n      this.debouncedSync = window.requestAnimationFrame(() => {\n        // The next animation frame is available, which means all operations\n        // have completed without the request being canceled. So, call `sync`\n        // and pass the batched data.\n        this.sync(this.stateBatch.newState, this.stateBatch.prevState);\n\n        // Reset state batch (removes unchanged state).\n        this.stateBatch = {};\n      });\n    });\n  }\n\n  stateHandler() {\n    return {\n      get: (store, state) => {\n        if([\"[object Object]\", \"[object Array]\"].indexOf(Object.prototype.toString.call(store[state])) > -1) {\n          return new Proxy(store[state], this.stateHandler());\n        }\n\n        return store[state];\n      },\n\n      // store = the object that `this.state` becomes.\n      // state = the property of the store object that was changed.\n      // value = the new value that the property was set to.\n      set: (store, state, value) => {\n        // Before setting the state prop to the new value, store the current,\n        // i.e. soon-to-be previous, value for later reference.\n        const prevState = {};\n        prevState[state] = store[state];\n\n        // Also provide the state that was changed for later reference. Helpful\n        // for determining which DOM elements to manipulate based on the state\n        // that was actually changed.\n        const newState = {};\n        newState[state] = value;\n\n        // Check that the new state is different.\n        if(store[state] !== value) {\n          // Set state prop to the new value.\n          store[state] = value;\n\n          // Dispatch a listenable event that signals state has changed, with\n          // details about the state change.\n          this.element.dispatchEvent(new CustomEvent(\"state-change\", {\n            detail: {\n              context: this.element,\n              newState: newState,\n              prevState: prevState,\n            },\n          }));\n        }\n\n        return true;\n      },\n    };\n  }\n\n  /**\n   * Each extending component subclass should have its own `sync` method, which\n   * will be responsible for all DOM manipulation. Since the method is called on\n   * every state change, it keeps the UI and state in sync, hence the name. As a\n   * result, it is best practice to always reference the current state when\n   * manipulating the DOM.\n   *\n   * @param {object} newState - An object containing only a copy of the changed\n   * state properties and their current values.\n   * @param {object} prevState - An object containing only a copy of the changed\n   * state properties and their previous values.\n   */\n  sync(newState, prevState) {\n    // Note that the subclass's `sync` method will override this one. If one is\n    // not present, this method will fire instead, so a warning should be\n    // logged.\n    console.warn(\"No local sync method provided in component subclass.\");\n  }\n}","/**\n * Generates a slug from a given string. Makes it usable as an ident, class, URL\n * path, file name, etc.\n *\n * Takes a string, trims white space, removes diacritics from the base letter,\n * lowercases all letters, replaces non-alphanumeric characters with a space,\n * removes double spaces, then replaces all single spaces with a separator (a\n * hyphen unless otherwise specified).\n *\n * Note that this does not generate unique IDs because it doesn't track reuse.\n *\n * @param {string} [separator=\"-\"] A character to insert between words (i.e.\n * replace spaces) within the slug.\n *\n * @returns {string} A slug.\n */\n\nString.prototype.slugify = function(separator = \"-\") {\n  return this\n    // Trim leading and trailing white space.\n    .trim()\n    // Remove diacritics from base letter.\n    .normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\")\n    // Convert to lowercase.\n    .toLowerCase()\n    // Replace remaining non-alphanumeric characters with space.\n    .replace(/[^\\w\\s]/gi, \" \")\n    // Replace multiple spaces with single space.\n    .replace(/\\s\\s+/g, \" \")\n    // Replace white space with separator.\n    .replace(/\\s+/g, separator);\n}"]}