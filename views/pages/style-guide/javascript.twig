{# DO NOT EDIT. This file was compiled from Markdown; please edit the source .md
file and run the gulp process to compile (either `gulp` or `npm run dev` from
the terminal). #}
{% extends "@tch/base.twig" %}
{% block lede %}Writing JavaScript for Texas Children's products.{% endblock %}
{% block body %}
<p>The following style guide applies to hand-authored, source JavaScript.</p>
<h2 id="formatting">Formatting</h2>
<p>Download and use the <a href="https://github.com/jacecotton/tcds/blob/main/.eslintrc">.eslintrc</a> file to take care of the more basic formatting rules automatically.</p>
<ul>
<li>Always include optional semicolons (at the end of expressions) and commas (after the last item in an object).</li>
<li>Always include optional braces for conditional statements.</li>
<li>White space and returns:<ul>
<li>Use exactly one return after an opening brace and before a closing brace.</li>
<li>Use no space before an opening parenthesis, and exactly one space and no return between a closing parenthesis and an opening brace.</li>
<li>Use no space after an opening parenthesis or before a closing parenthesis. Use returns within parentheses only if the line becomes excessively long.</li>
<li>Use exactly one space on each side of an operator and after any commas.</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// Correct
function name(param) {
  if(condition === true) {
    return param + 1;
  }
}

// Incorrect
function name( param )
{
  if (condition===true) return param+2
}
</code></pre>
<ul>
<li>In arrow functions:<ul>
<li>Use optional parentheses for a single parameter if braces are used to delimit the function body.</li>
<li>Only omit the braces if the function body is its return value.</li>
<li>If braces are used, use one return after the opening brace, and before the closing brace.</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// Correct
const myFunction = (param1, param2) =&gt; {
  return result;
};

const myFunction = param =&gt; result;

// Incorrect
const myFunction = (param1, param2) =&gt; { return result };

const myFunction = param =&gt; {
  return result;
};
</code></pre>
<h2 id="case">Case</h2>
<ul>
<li>Use <code>camelCase</code> for variables, property keys, and methods.</li>
<li>Use <code>PascalCase</code> for constructors (classes) and objects.</li>
</ul>
<h2 id="scoping-and-variables">Scoping and variables</h2>
<ul>
<li>To declare variables:<ul>
<li>Do not use <code>var</code> or globally-scoped variables unless absolutely needed for a clear and documented reason.</li>
<li>Default to <code>const</code>, which is safest by default, as it does not allow mutation or redefinition, and is block-scoped. This promises to other developers that the variable is not mutated at any other point in the code.</li>
<li>While it should be avoided if possible, if there is a need to allow the variable to be mutated, use <code>let</code>, which is block-scoped. This implies to other developers that the variable is to be mutated at some other point in the code.</li>
</ul>
</li>
</ul>
<h2 id="naming">Naming</h2>
<ul>
<li>For boolean variables and functions that return a boolean, prefer prefixing the names with yes/no question verbs (<code>is</code>, <code>has</code>, <code>was</code>, etc.)</li>
</ul>
<pre><code class="language-js">// Acceptable
const onlyOne = parent.children.length === 1;
const lastChild = parent.children.indexOf(element) === parent.children.length - 1;

// Better
const hasOnlyOne = parent.children.length === 1;
const isLastChild = parent.children.indexOf(element) === parent.children.length - 1;
</code></pre>
<ul>
<li>Use clear and self-documenting names. Do not use single letters or abstracted names that don&#39;t actually provide self-documentation.</li>
</ul>
<pre><code class="language-js">// Acceptable
let index = 0;
const nextElement = parent.children[parent.children.indexOf(element) + 1];

// Unacceptable
let i = 0; // Not clear
const getElementIncrementedByOneFromCurrentIndex =
  parent.children[parent.children.indexOf(element) + 1]; // Not helpful
</code></pre>
<ul>
<li>Use concise names, but do not use uncommon abbreviations or needless truncations. Prioritize readability and self-documentation over concision and typability. All names are reduced during minification anyway.</li>
</ul>
<pre><code class="language-js">// Acceptable
const previousButton;
const prevButton; // Common abbreviation; not required, but acceptable
const getItemByRouteName;

// Unacceptable
const prevBtn; // Uncommon abbreviation; &quot;button&quot; is sufficiently short
const getItem; // Vague; get item of what? By what?
</code></pre>
<h2 id="programming-style">Programming style</h2>
<ul>
<li>Where appropriate, prefer declarative programming over imperative.</li>
</ul>
<pre><code class="language-js">// Acceptable
let result;

if(condition) {
  result = &quot;foo&quot;;
} else {
  result = &quot;bar&quot;;
}

// Better
const result = condition ? &quot;foo&quot; : &quot;bar&quot;;
</code></pre>
<ul>
<li>Where appropriate, prefer pure functions over impure.</li>
</ul>
<pre><code class="language-js">// Acceptable: Impure function creates mutation, causing side-effect.
let x = 2;
increment();

function increment() {
  x = x + 1;
}

// Better: Pure function does not create mutation, no side-effects.
let x = 2;
x = increment(x);

function increment(n) {
  return n + 1;
}
</code></pre>
{% endblock %}