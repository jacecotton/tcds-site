{# DO NOT EDIT. This file was compiled from Markdown; please edit the source .md
file and run the gulp process to compile (either `gulp` or `npm run dev` from
the terminal). #}
{% extends "@tch/base.twig" %}
{% block body %}
<h2 id="javascript">JavaScript</h2>
<h3 id="state-driven-components">State-driven components</h3>
<p>Interactive, state-driven components can be managed with the <code>Component</code> superclass utility. It allows you to change the state of a component <em>declaratively</em>, then have a dedicated function, <code>sync()</code>, responsible for any DOM manipulation in response (<em>imperatively</em>). The boilerplate is as follows:</p>
<pre><code class="language-javascript">/* Extend the Component parent class. */
class Example extends Component {
  /* Pass the root component element and its props (options, settings, etc.) */
  constructor(element, props) {
    /* Invoke the constructor of the parent Component class and pass the element
       and props. */
    super(element, props);

    /* Event listeners, data fetching, timers, and consequent changes to
       `this.state` go here. */
  }

  /* Called on every change to `this.state`. */
  sync(newState, prevState) {
    /* DOM manipulation goes here. */
  }
}

/* Get all &quot;Example&quot; component instances. */
document.querySelectorAll(&quot;[data-component=Example]&quot;).forEach((element) =&gt; {
  /* Instantiate the component. */
  new Example(element, {
    /* Options go here. */
  });
});
</code></pre>
<p>The <code>element</code> parameter refers to the root-most HTML element to which the component script applies. The <code>props</code> parameter refers to the object passed by the user of a component at time of instantiation. This is then transformed into a <code>this.props</code> internal object, which is an immutable reference to the &quot;settings&quot; passed by the user.</p>
<p>The component superclass provides one more important property, <code>this.state</code>. This allows you to store data about the current &quot;state&quot; of the <code>element</code> and its children. Every time <code>this.state</code> is changed, the <code>sync()</code> method is called with data about the state that was changed, its new value (<code>newState</code>), and its previous value (<code>prevState</code>).</p>
<p>As an example, the below script initiates a <code>count</code> state to <code>1</code>, as passed via the <code>props</code> argument at time of instantiation. Then, every time the <code>element</code> is clicked, <code>count</code> increments by <code>1</code>.</p>
<pre><code class="language-javascript">class Counter extends Component {
  constructor(element, props) {
    // Must pass element and props to parent class via super. This will
    // transform the bare `element` and `props` arguments into properties of the
    // current object (`this`).
    super(element, props);

    // Initialize state `count` from the initial value given from `props`.
    this.state.count = this.props.count;

    // When the element is clicked...
    this.element.addEventListener(&quot;click&quot;, () =&gt; {
      // Increment the count state.
      this.state.count++;
    });
  }

  // This function is called every time `this.state` is changed.
  sync(newState, prevState) {
    // Will log 1 first, then 2 when clicked, then 3, etc.
    console.log(this.state.count);

    // You can do stuff with this.state, newState, and prevState here.
  }
}

// Create a new `Counter` component out of a `#my-element` element.
new Counter(document.getElementById(&quot;my-element&quot;), {
  count: 1, // Start count at 1
});
</code></pre>
<h3 id="state-diffing-and-batching">State diffing and batching</h3>
<p>Say we have multiple properties belonging to <code>this.state</code>. Maybe we want to limit the number of clicks to 5. We don&#39;t want operations in <code>sync()</code> that are only relevant to changes to <code>this.state.count</code> to run when we change <code>this.state.reachedMaximumClicks</code>. So, we can check whether a property exists in <code>newState</code> before running operations:</p>
<pre><code class="language-javascript">class Counter extends Component {
  constructor(element, props) {
    super(element, props);

    this.state.count = this.props.count;

    this.element.addEventListener(&quot;click&quot;, () =&gt; {
      if(this.state.count &lt; this.props.maximumClicks) {
        this.state.count++;
      } else {
        this.state.reachedMaximumClicks = true;
      }
    });
  }

  sync(newState, prevState) {
    if(&quot;count&quot; in newState) {
      // This will only run if the state property that triggered the current
      // sync call was this.state.count.
    }

    if(&quot;reachedMaximumClicks&quot; in newState) {
      // This only runs if this.state.reachedMaximumClicks was changed.
    }
  }
}
</code></pre>
<p>One important thing to note is state changes are <strong>batched</strong>. This means that if you update multiple <code>this.state</code> properties back-to-back, the component utility will only run <code>sync()</code> once, passing all the changed state in one bundle (an object) to the <code>newState</code> parameter. Under the hood, the utility uses a <code>requestAnimationFrame</code> callback to <strong>debounce</strong> the <code>sync</code> call.</p>
{% endblock %}