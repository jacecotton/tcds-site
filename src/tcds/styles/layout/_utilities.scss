@use "../" as *;

.max-width-container {
  margin: 0 auto;
  width: calc(100% - size("x-large"));
  max-width: breakpoint("max");
}

/**
 * Flexbox utilities.
 */

// Creates a flex container with a row flow.
.row {
  display: flex;
  flex-direction: row;
}

// Creates a flex container with a column flow.
.column {
  display: flex;
  flex-direction: column;
}

// Allows items to wrap onto a new row.
.row-wrap,
.column-wrap {
  flex-wrap: wrap;
}

// Sets a proportional flex unit (1 through 12) for use on flex items (children
// of flex containers).
@for $flex from 1 through 12 {
  .flex-#{$flex} {
    flex: $flex;
  }
}

/**
 * Grid utilities.
 */

/**
 * Creates a grid container (for barebones grid usage). Properties can be
 * adjusted through inline styles that set any of the following custom
 * properties (all optional):
 *   --grid-columns: The number of evenly spaced columns (default 1), or other
 *   valid argument for `repeat()` first parameter (e.g. `auto-fit`,
 *   `auto-fill`).
 *   --grid-column-min-width: If --grid-columns is set to `auto-fit` or
 *   `auto-fill`, the minimum size of each column before wrapping.
 *
 * 1. IE supports grid but not custom properties, so fallback to single-column
 *    layout.
 */
.grid {
  display: grid;
  -ms-grid-columns: 1fr; // 1
  grid-template-columns: repeat(var(--grid-columns, 1), minmax(var(--grid-column-min-width, 0px), 1fr));
}

/**
 * Utilities for flexbox or grid.
 *
 * These are not intended to simply map all possible flex/grid properties to
 * utility classes, but rather to provide convenient access to the most commonly
 * used ones.
 *
 * Using these utilities assumes some flexbox/grid familiarity, but basic
 * vocabulary is documented here for reference:
 * justify - horizontal alignment if row, vertical alignment if column.
 * align - vertical alignment if row, horizontal alignment if column.
 * start - left if row, top if column (inverse if RTL or reverse flow).
 * end - right if row, bottom if column (inverse if RTL or reverse flow).
 * main axis - horizontal axis if row, vertical axis if column.
 * cross axis - vertical axis if row, horizontal axis if column.
 * inline - flow or direction along the main axis; i.e., left/right if row, top/
 * bottom if column.
 * block - flow or direction along the cross axis; i.e., top/bottom if row,
 * left/right if column.
 */

// Justifies the first item's block start (e.g. left side) flush to the start of
// the main axis (e.g. left boundary), and the last item in the row/column's
// block end (e.g. right side) flush to the end of the main axis (e.g. right
// boundary), then evenly spaces items between them within the row/column.
.justify-space-between {
  justify-content: space-between;
}

// Justifies all content to the start of the main axis.
.justify-start,
.justify-left {
  justify-content: start;
}

// Justifies all content to the end of the main axis.
.justify-end,
.justify-right {
  justify-content: end;
}

// Justifies all content to the center along the main axis.
.justify-center {
  justify-content: center;
}

// Aligns all items to the center along the cross axis.
.align-center {
  align-items: center;
}

// Aligns all items so their block start is flush with the start of the cross
// axis.
.align-start,
.align-top {
  align-items: start;
}

// Aligns all items so their block end is flush to the end of the cross axis.
.align-end,
.align-bottom {
  align-items: end;
}

@each $gap-level, $gap-value in $spaces {
  .gap-#{$gap-level} {
    gap: $gap-value;
  }

  .row-gap-#{$gap-level} {
    row-gap: $gap-value;
  }
  
  .column-gap-#{$gap-level} {
    column-gap: $gap-value;
  }
}